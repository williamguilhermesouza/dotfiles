"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GraphQLWatchman = void 0;

var _fbWatchman = _interopRequireDefault(require("fb-watchman"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class GraphQLWatchman {
  constructor() {
    _defineProperty(this, "_client", void 0);

    this._client = new _fbWatchman.default.Client();
  }

  checkVersion() {
    return new Promise((resolve, reject) => {
      this._client.capabilityCheck({
        optional: [],
        required: ['cmd-watch-project']
      }, (error, response) => {
        if (error) {
          reject(error);
        } else {
          // From the Watchman docs, response is something like:
          // {'version': '3.8.0', 'capabilities': {'relative_root': true}}.
          resolve();
        }
      });

      this._client.on('error', reject);
    });
  }

  async listFiles(entryPath, options = {}) {
    const {
      watch,
      relative_path
    } = await this.watchProject(entryPath);
    const result = await this.runCommand('query', watch, {
      expression: ['allof', ['type', 'f'], ['anyof', ['match', '*.graphql'], ['match', '*.js']], ['not', ['dirname', 'generated/relay']], ['not', ['match', '**/__flow__/**', 'wholename']], ['not', ['match', '**/__generated__/**', 'wholename']], ['not', ['match', '**/__github__/**', 'wholename']], ['not', ['match', '**/__mocks__/**', 'wholename']], ['not', ['match', '**/node_modules/**', 'wholename']], ['not', ['match', '**/__flowtests__/**', 'wholename']], ['exists']],
      // Providing `path` will let watchman use path generator, and will perform
      // a tree walk with respect to the relative_root and path provided.
      // Path generator will do less work unless the root path of the repository
      // is passed in as an entry path.
      fields: ['name', 'size', 'mtime'],
      relative_root: relative_path,
      ...options
    });
    return result.files;
  }

  runCommand(...args) {
    return new Promise((resolve, reject) => this._client.command(args, (error, response) => {
      if (error) {
        reject(error);
      }

      resolve(response);
    })).catch(error => {
      throw new Error(error);
    });
  }

  async watchProject(directoryPath) {
    try {
      const response = await this.runCommand('watch-project', directoryPath);
      return response;
    } catch (error) {
      throw new Error(error);
    }
  }

  async subscribe(entryPath, callback) {
    const {
      watch,
      relative_path
    } = await this.watchProject(entryPath);
    await this.runCommand('subscribe', watch, relative_path || watch, {
      expression: ['allof', ['match', '*.graphql']],
      fields: ['name', 'exists', 'size', 'mtime'],
      relative_root: relative_path
    });

    this._client.on('subscription', result => {
      if (result.subscription !== relative_path) {
        return;
      }

      callback(result);
    });
  }

  dispose() {
    this._client.end();

    this._client = null;
  }

}

exports.GraphQLWatchman = GraphQLWatchman;