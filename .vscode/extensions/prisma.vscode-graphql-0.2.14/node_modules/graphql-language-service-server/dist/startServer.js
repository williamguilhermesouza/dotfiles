"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _net = _interopRequireDefault(require("net"));

var _GraphQLWatchman = require("./GraphQLWatchman");

var _MessageProcessor = require("./MessageProcessor");

var _vscodeJsonrpc = require("vscode-jsonrpc");

var _vscodeLanguageserver = require("vscode-languageserver");

var _Logger = require("./Logger");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 *  Copyright (c) 2019 GraphQL Contributors
 *  All rights reserved.
 *
 *  This source code is licensed under the license found in the
 *  LICENSE file in the root directory of this source tree.
 *
 *  
 */
var startServer = async function startServer(options) {
  const logger = new _Logger.Logger();

  if (options && options.method) {
    let reader;
    let writer;

    switch (options.method) {
      case 'socket':
        // For socket connection, the message connection needs to be
        // established before the server socket starts listening.
        // Do that, and return at the end of this block.
        if (!options.port) {
          process.stderr.write('--port is required to establish socket connection.');
          process.exit(1);
          return;
        }

        const port = options.port;

        const socket = _net.default.createServer(client => {
          client.setEncoding('utf8');
          reader = new _vscodeJsonrpc.SocketMessageReader(client);
          writer = new _vscodeJsonrpc.SocketMessageWriter(client);
          client.on('end', () => {
            socket.close();
            process.exit(0);
          });
          const connection = (0, _vscodeJsonrpc.createMessageConnection)(reader, writer, logger);
          addHandlers(connection, options.configDir, logger);
          connection.listen();
        }).listen(port);

        return;

      case 'stream':
        reader = new _vscodeJsonrpc.StreamMessageReader(process.stdin);
        writer = new _vscodeJsonrpc.StreamMessageWriter(process.stdout);
        break;

      case 'node':
      default:
        reader = new _vscodeJsonrpc.IPCMessageReader(process);
        writer = new _vscodeJsonrpc.IPCMessageWriter(process);
        break;
    }

    const connection = (0, _vscodeJsonrpc.createMessageConnection)(reader, writer, logger);
    addHandlers(connection, options.configDir, logger);
    connection.listen();
  }
};

exports.default = startServer;

function addHandlers(connection, configDir, logger) {
  const messageProcessor = new _MessageProcessor.MessageProcessor(logger, new _GraphQLWatchman.GraphQLWatchman());
  connection.onNotification(_vscodeLanguageserver.DidOpenTextDocumentNotification.type, async params => {
    const diagnostics = await messageProcessor.handleDidOpenOrSaveNotification(params);

    if (diagnostics) {
      connection.sendNotification(_vscodeLanguageserver.PublishDiagnosticsNotification.type, diagnostics);
    }
  });
  connection.onNotification(_vscodeLanguageserver.DidSaveTextDocumentNotification.type, async params => {
    const diagnostics = await messageProcessor.handleDidOpenOrSaveNotification(params);

    if (diagnostics) {
      connection.sendNotification(_vscodeLanguageserver.PublishDiagnosticsNotification.type, diagnostics);
    }
  });
  connection.onNotification(_vscodeLanguageserver.DidChangeTextDocumentNotification.type, async params => {
    const diagnostics = await messageProcessor.handleDidChangeNotification(params);

    if (diagnostics) {
      connection.sendNotification(_vscodeLanguageserver.PublishDiagnosticsNotification.type, diagnostics);
    }
  });
  connection.onNotification(_vscodeLanguageserver.DidCloseTextDocumentNotification.type, params => messageProcessor.handleDidCloseNotification(params));
  connection.onRequest(_vscodeLanguageserver.ShutdownRequest.type, () => messageProcessor.handleShutdownRequest());
  connection.onNotification(_vscodeLanguageserver.ExitNotification.type, () => messageProcessor.handleExitNotification()); // Ignore cancel requests

  connection.onNotification('$/cancelRequest', () => ({}));
  connection.onRequest(_vscodeLanguageserver.InitializeRequest.type, (params, token) => messageProcessor.handleInitializeRequest(params, token, configDir));
  connection.onRequest(_vscodeLanguageserver.CompletionRequest.type, params => messageProcessor.handleCompletionRequest(params));
  connection.onRequest(_vscodeLanguageserver.CompletionResolveRequest.type, item => item);
  connection.onRequest(_vscodeLanguageserver.DefinitionRequest.type, params => messageProcessor.handleDefinitionRequest(params));
  connection.onRequest(_vscodeLanguageserver.HoverRequest.type, params => messageProcessor.handleHoverRequest(params));
  connection.onNotification(_vscodeLanguageserver.DidChangeWatchedFilesNotification.type, params => messageProcessor.handleWatchedFilesChangedNotification(params));
}