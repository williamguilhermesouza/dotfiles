"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript/lib/tsserverlibrary");
const graphql_language_service_interface_1 = require("@divyenduz/graphql-language-service-interface");
const graphql_config_1 = require("graphql-config");
const path_1 = require("path");
class GraphQLLanguageServiceProxy {
    constructor(info, logger) {
        this._info = info;
        this._logger = logger;
    }
    /*
      Use the configration of first project if heuristics failed
      to find one.
    */
    patchProjectConfig(config) {
        if (!config.config.projects) {
            return config;
        }
        if (config.config.projects) {
            const projectKeys = Object.keys(config.config.projects);
            return config.getProjectConfig(projectKeys[0]);
        }
        return null;
    }
    isRootDir(path) {
        return path_1.dirname(path) === path;
    }
    getProjectConfig(fileName) {
        let config = graphql_config_1.getGraphQLConfig();
        let currentDir = path_1.dirname(fileName);
        this._logger(`fileName: ${fileName}`);
        this._logger(`currentDir: ${currentDir}`);
        while (!this.isRootDir(currentDir)) {
            try {
                config = graphql_config_1.getGraphQLConfig(currentDir);
                this._logger(`Found GraphQL Config for ${currentDir}`);
                break;
            }
            catch (e) {
                this._logger(`Failed to find GraphQL Config for ${currentDir}`);
            }
            currentDir = path_1.dirname(currentDir);
        }
        let projectConfig = config.getConfigForFile(fileName);
        if (!projectConfig) {
            projectConfig = this.patchProjectConfig(config);
        }
        return projectConfig;
    }
    getCompletionsAtPosition(context, position) {
        try {
            const projectConfig = this.getProjectConfig(context.fileName);
            const schema = projectConfig.getSchema();
            const completions = graphql_language_service_interface_1.getAutocompleteSuggestions(schema, context.text, position);
            const completionInfo = {
                isGlobalCompletion: false,
                isMemberCompletion: false,
                isNewIdentifierLocation: false,
                entries: completions.map(completion => {
                    return {
                        name: completion.label,
                        kind: completion.kind
                            ? completion.kind
                            : ts.ScriptElementKind.unknown,
                        kindModifiers: "gql",
                        sortText: "gql"
                    };
                })
            };
            this._logger(`completionInfo: ${JSON.stringify(completionInfo)}`);
            return completionInfo;
        }
        catch (e) {
            this._logger(`getCompletionsAtPosition: Unhandled exception: ${e}`);
            return {
                isGlobalCompletion: false,
                isMemberCompletion: false,
                isNewIdentifierLocation: false,
                entries: []
            };
        }
    }
    getSemanticDiagnostics(context) {
        try {
            const projectConfig = this.getProjectConfig(context.fileName);
            const schema = projectConfig.getSchema();
            const diagnostics = graphql_language_service_interface_1.getDiagnostics(context.text, schema);
            this._logger(`diagnostics: ${JSON.stringify(diagnostics)}`);
            const transformedDiagnostics = diagnostics
                .map(diagnostic => {
                const code = typeof diagnostic.code === "number" ? diagnostic.code : 9999;
                const messageText = diagnostic.message.split("\n")[0];
                const transformedDiagnostic = {
                    code,
                    messageText,
                    category: diagnostic.severity,
                    file: context.fileName,
                    start: 0,
                    length: 0
                };
                return transformedDiagnostic;
            })
                .filter(diagnostic => !diagnostic.messageText.includes("xxxxxxxxxxxx"));
            this._logger(`transformedDiagnostics: ${JSON.stringify(transformedDiagnostics)}`);
            return transformedDiagnostics;
        }
        catch (e) {
            this._logger(`getSemanticDiagnostics: Unhandled exception: ${e}`);
            return [];
        }
    }
}
exports.default = GraphQLLanguageServiceProxy;
