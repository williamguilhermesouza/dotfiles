'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MessageProcessor = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.getQueryAndRange = getQueryAndRange;

var _graphqlLanguageServiceTypes = require('@divyenduz/graphql-language-service-types');

var _path = require('path');

var _fs = require('fs');

var _url = require('url');

var _graphqlConfig = require('graphql-config');

var _graphqlLanguageServiceInterface = require('@divyenduz/graphql-language-service-interface');

var _graphqlLanguageServiceUtils = require('@divyenduz/graphql-language-service-utils');

var _vscodeJsonrpc = require('vscode-jsonrpc');

var _vscodeLanguageserver = require('vscode-languageserver');

var _GraphQLCache = require('./GraphQLCache');

var _findGraphQLTags = require('./findGraphQLTags');

var _Logger = require('./Logger');

var _GraphQLWatchman = require('./GraphQLWatchman');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
                                                                                                                                                           *  Copyright (c) Facebook, Inc.
                                                                                                                                                           *  All rights reserved.
                                                                                                                                                           *
                                                                                                                                                           *  This source code is licensed under the license found in the
                                                                                                                                                           *  LICENSE file in the root directory of this source tree.
                                                                                                                                                           *
                                                                                                                                                           *  
                                                                                                                                                           */

// Map { uri => { query, range } }

var MessageProcessor = exports.MessageProcessor = function () {
  function MessageProcessor(logger, watchmanClient, extensions) {
    _classCallCheck(this, MessageProcessor);

    this._textDocumentCache = new Map();
    this._isInitialized = false;
    this._willShutdown = false;

    this._logger = logger;
    this._watchmanClient = watchmanClient;

    this._extensions = extensions;
  }

  MessageProcessor.prototype.handleInitializeRequest = function handleInitializeRequest(params, token, configDir) {
    var serverCapabilities, rootPath, config, i, extension;
    return regeneratorRuntime.async(function handleInitializeRequest$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (params) {
              _context.next = 2;
              break;
            }

            throw new Error('`params` argument is required to initialize.');

          case 2:
            serverCapabilities = {
              capabilities: {
                completionProvider: { resolveProvider: true },
                definitionProvider: true,
                textDocumentSync: 1,
                hoverProvider: true
              }
            };
            rootPath = (0, _path.dirname)((0, _graphqlConfig.findGraphQLConfigFile)(configDir ? configDir.trim() : params.rootPath));

            if (rootPath) {
              _context.next = 6;
              break;
            }

            throw new Error('`--configDir` option or `rootPath` argument is required.');

          case 6:
            _context.next = 8;
            return regeneratorRuntime.awrap((0, _GraphQLCache.getGraphQLCache)(rootPath, this._extensions));

          case 8:
            this._graphQLCache = _context.sent;
            config = (0, _graphqlConfig.getGraphQLConfig)(rootPath);

            if (!(this._extensions && this._extensions.length > 0)) {
              _context.next = 20;
              break;
            }

            i = 0;

          case 12:
            if (!(i < this._extensions.length)) {
              _context.next = 20;
              break;
            }

            extension = this._extensions[i];
            _context.next = 16;
            return regeneratorRuntime.awrap(extension(config));

          case 16:
            config = _context.sent;

          case 17:
            i++;
            _context.next = 12;
            break;

          case 20:

            if (this._watchmanClient) {
              this._subcribeWatchman(config, this._watchmanClient);
            }
            this._languageService = new _graphqlLanguageServiceInterface.GraphQLLanguageService(this._graphQLCache);

            if (serverCapabilities) {
              _context.next = 24;
              break;
            }

            throw new Error('GraphQL Language Server is not initialized.');

          case 24:

            this._isInitialized = true;

            this._logger.log(JSON.stringify({
              type: 'usage',
              messageType: 'initialize'
            }));

            return _context.abrupt('return', serverCapabilities);

          case 27:
          case 'end':
            return _context.stop();
        }
      }
    }, null, this);
  };

  // Use watchman to subscribe to project file changes only if watchman is
  // installed. Otherwise, rely on LSP watched files did change events.


  MessageProcessor.prototype._subcribeWatchman = function _subcribeWatchman(config, watchmanClient) {
    var _this = this;

    var projectMap, projectConfigs;
    return regeneratorRuntime.async(function _subcribeWatchman$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (watchmanClient) {
              _context2.next = 2;
              break;
            }

            return _context2.abrupt('return');

          case 2:
            _context2.prev = 2;
            _context2.next = 5;
            return regeneratorRuntime.awrap(watchmanClient.checkVersion());

          case 5:

            // Otherwise, subcribe watchman according to project config(s).
            projectMap = config.getProjects();
            projectConfigs = projectMap ? Object.values(projectMap) : [];

            // There can either be a single config or one or more project
            // configs, but not both.

            if (projectConfigs.length === 0) {
              projectConfigs = [config.getProjectConfig()];
            }

            // For each project config, subscribe to the file changes and update the
            // cache accordingly.
            projectConfigs.forEach(function (projectConfig) {
              watchmanClient.subscribe(projectConfig.configDir, _this._graphQLCache.handleWatchmanSubscribeEvent(config.configDir, projectConfig));
            });
            _context2.next = 18;
            break;

          case 11:
            _context2.prev = 11;
            _context2.t0 = _context2['catch'](2);

            if (!(_context2.t0.code === 'ENOENT')) {
              _context2.next = 17;
              break;
            }

            this._watchmanClient = undefined;
            _context2.next = 18;
            break;

          case 17:
            throw _context2.t0;

          case 18:
          case 'end':
            return _context2.stop();
        }
      }
    }, null, this, [[2, 11]]);
  };

  MessageProcessor.prototype.handleDidOpenOrSaveNotification = function handleDidOpenOrSaveNotification(params) {
    var _this2 = this;

    var textDocument, text, uri, diagnostics, contents, cachedDocument;
    return regeneratorRuntime.async(function handleDidOpenOrSaveNotification$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            if (this._isInitialized) {
              _context4.next = 2;
              break;
            }

            return _context4.abrupt('return', null);

          case 2:
            if (!(!params || !params.textDocument)) {
              _context4.next = 4;
              break;
            }

            throw new Error('`textDocument` argument is required.');

          case 4:
            textDocument = params.textDocument;
            text = textDocument.text, uri = textDocument.uri;
            diagnostics = [];
            contents = [];

            // Create/modify the cached entry if text is provided.
            // Otherwise, try searching the cache to perform diagnostics.

            if (text || text === '') {
              // textDocument/didSave does not pass in the text content.
              // Only run the below function if text is passed in.
              contents = getQueryAndRange(text, uri);
              this._invalidateCache(textDocument, uri, contents);
            } else {
              cachedDocument = this._getCachedDocument(uri);

              if (cachedDocument) {
                contents = cachedDocument.contents;
              }
            }

            _context4.next = 11;
            return regeneratorRuntime.awrap(Promise.all(contents.map(function _callee(_ref) {
              var query = _ref.query,
                  range = _ref.range;
              var results;
              return regeneratorRuntime.async(function _callee$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      _context3.next = 2;
                      return regeneratorRuntime.awrap(_this2._languageService.getDiagnostics(query, uri, _this2._isRelayCompatMode(query) ? false : true));

                    case 2:
                      results = _context3.sent;

                      if (results && results.length > 0) {
                        diagnostics.push.apply(diagnostics, processDiagnosticsMessage(results, query, range));
                      }

                    case 4:
                    case 'end':
                      return _context3.stop();
                  }
                }
              }, null, _this2);
            })));

          case 11:

            this._logger.log(JSON.stringify({
              type: 'usage',
              messageType: 'textDocument/didOpen',
              projectName: this._graphQLCache.getGraphQLConfig().getProjectNameForFile(uri),
              fileName: uri
            }));

            return _context4.abrupt('return', { uri: uri, diagnostics: diagnostics });

          case 13:
          case 'end':
            return _context4.stop();
        }
      }
    }, null, this);
  };

  MessageProcessor.prototype.handleDidChangeNotification = function handleDidChangeNotification(params) {
    var _this3 = this;

    var textDocument, contentChanges, contentChange, uri, contents, cachedDocument, diagnostics;
    return regeneratorRuntime.async(function handleDidChangeNotification$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            if (this._isInitialized) {
              _context6.next = 2;
              break;
            }

            return _context6.abrupt('return', null);

          case 2:
            if (!(!params || !params.textDocument || !params.contentChanges || !params.textDocument.uri)) {
              _context6.next = 4;
              break;
            }

            throw new Error('`textDocument`, `textDocument.uri`, and `contentChanges` arguments are required.');

          case 4:
            textDocument = params.textDocument;
            contentChanges = params.contentChanges;
            contentChange = contentChanges[contentChanges.length - 1];

            // As `contentChanges` is an array and we just want the
            // latest update to the text, grab the last entry from the array.

            uri = textDocument.uri || params.uri;

            // If it's a .js file, try parsing the contents to see if GraphQL queries
            // exist. If not found, delete from the cache.

            contents = getQueryAndRange(contentChange.text, uri);

            // If it's a .graphql file, proceed normally and invalidate the cache.

            this._invalidateCache(textDocument, uri, contents);

            cachedDocument = this._getCachedDocument(uri);

            if (cachedDocument) {
              _context6.next = 13;
              break;
            }

            return _context6.abrupt('return', null);

          case 13:

            this._updateFragmentDefinition(uri, contents);
            this._updateObjectTypeDefinition(uri, contents);

            // Send the diagnostics onChange as well
            diagnostics = [];
            _context6.next = 18;
            return regeneratorRuntime.awrap(Promise.all(contents.map(function _callee2(_ref2) {
              var query = _ref2.query,
                  range = _ref2.range;
              var results;
              return regeneratorRuntime.async(function _callee2$(_context5) {
                while (1) {
                  switch (_context5.prev = _context5.next) {
                    case 0:
                      _context5.next = 2;
                      return regeneratorRuntime.awrap(_this3._languageService.getDiagnostics(query, uri));

                    case 2:
                      results = _context5.sent;

                      if (results && results.length > 0) {
                        diagnostics.push.apply(diagnostics, processDiagnosticsMessage(results, query, range));
                      }

                    case 4:
                    case 'end':
                      return _context5.stop();
                  }
                }
              }, null, _this3);
            })));

          case 18:

            this._logger.log(JSON.stringify({
              type: 'usage',
              messageType: 'textDocument/didChange',
              projectName: this._graphQLCache.getGraphQLConfig().getProjectNameForFile(uri),
              fileName: uri
            }));

            return _context6.abrupt('return', { uri: uri, diagnostics: diagnostics });

          case 20:
          case 'end':
            return _context6.stop();
        }
      }
    }, null, this);
  };

  MessageProcessor.prototype.handleDidCloseNotification = function handleDidCloseNotification(params) {
    if (!this._isInitialized) {
      return;
    }
    // For every `textDocument/didClose` event, delete the cached entry.
    // This is to keep a low memory usage && switch the source of truth to
    // the file on disk.
    if (!params || !params.textDocument) {
      throw new Error('`textDocument` is required.');
    }
    var textDocument = params.textDocument;
    var uri = textDocument.uri;

    if (this._textDocumentCache.has(uri)) {
      this._textDocumentCache.delete(uri);
    }

    this._logger.log(JSON.stringify({
      type: 'usage',
      messageType: 'textDocument/didClose',
      projectName: this._graphQLCache.getGraphQLConfig().getProjectNameForFile(uri),
      fileName: uri
    }));
  };

  MessageProcessor.prototype.handleShutdownRequest = function handleShutdownRequest() {
    this._willShutdown = true;
    return;
  };

  MessageProcessor.prototype.handleExitNotification = function handleExitNotification() {
    process.exit(this._willShutdown ? 0 : 1);
  };

  MessageProcessor.prototype.validateDocumentAndPosition = function validateDocumentAndPosition(params) {
    if (!params || !params.textDocument || !params.textDocument.uri || !params.position) {
      throw new Error('`textDocument`, `textDocument.uri`, and `position` arguments are required.');
    }
  };

  MessageProcessor.prototype.handleCompletionRequest = function handleCompletionRequest(params, token) {
    var textDocument, position, cachedDocument, found, query, range, result;
    return regeneratorRuntime.async(function handleCompletionRequest$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            if (this._isInitialized) {
              _context7.next = 2;
              break;
            }

            return _context7.abrupt('return', []);

          case 2:

            this.validateDocumentAndPosition(params);

            textDocument = params.textDocument;
            position = params.position;

            // `textDocument/completion` event takes advantage of the fact that
            // `textDocument/didChange` event always fires before, which would have
            // updated the cache with the query text from the editor.
            // Treat the computed list always complete.

            cachedDocument = this._getCachedDocument(textDocument.uri);

            if (cachedDocument) {
              _context7.next = 8;
              break;
            }

            throw new Error('A cached document cannot be found.');

          case 8:
            found = cachedDocument.contents.find(function (content) {
              var currentRange = content.range;
              if (currentRange && currentRange.containsPosition(position)) {
                return true;
              }
            });

            // If there is no GraphQL query in this file, return an empty result.

            if (found) {
              _context7.next = 11;
              break;
            }

            return _context7.abrupt('return', []);

          case 11:
            query = found.query, range = found.range;


            if (range) {
              position.line -= range.start.line;
            }
            _context7.next = 15;
            return regeneratorRuntime.awrap(this._languageService.getAutocompleteSuggestions(query, position, textDocument.uri));

          case 15:
            result = _context7.sent;


            this._logger.log(JSON.stringify({
              type: 'usage',
              messageType: 'textDocument/completion',
              projectName: this._graphQLCache.getGraphQLConfig().getProjectNameForFile(textDocument.uri),
              fileName: textDocument.uri
            }));

            return _context7.abrupt('return', { items: result, isIncomplete: false });

          case 18:
          case 'end':
            return _context7.stop();
        }
      }
    }, null, this);
  };

  MessageProcessor.prototype.handleHoverRequest = function handleHoverRequest(params, token) {
    var textDocument, position, cachedDocument, found, query, range, result;
    return regeneratorRuntime.async(function handleHoverRequest$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            if (this._isInitialized) {
              _context8.next = 2;
              break;
            }

            return _context8.abrupt('return', []);

          case 2:

            this.validateDocumentAndPosition(params);

            textDocument = params.textDocument;
            position = params.position;
            cachedDocument = this._getCachedDocument(textDocument.uri);

            if (cachedDocument) {
              _context8.next = 8;
              break;
            }

            throw new Error('A cached document cannot be found.');

          case 8:
            found = cachedDocument.contents.find(function (content) {
              var currentRange = content.range;
              if (currentRange && currentRange.containsPosition(position)) {
                return true;
              }
            });

            // If there is no GraphQL query in this file, return an empty result.

            if (found) {
              _context8.next = 11;
              break;
            }

            return _context8.abrupt('return', '');

          case 11:
            query = found.query, range = found.range;


            if (range) {
              position.line -= range.start.line;
            }
            _context8.next = 15;
            return regeneratorRuntime.awrap(this._languageService.getHoverInformation(query, position, textDocument.uri));

          case 15:
            result = _context8.sent;
            return _context8.abrupt('return', {
              contents: result
            });

          case 17:
          case 'end':
            return _context8.stop();
        }
      }
    }, null, this);
  };

  MessageProcessor.prototype.handleWatchedFilesChangedNotification = function handleWatchedFilesChangedNotification(params) {
    var _this4 = this;

    return regeneratorRuntime.async(function handleWatchedFilesChangedNotification$(_context11) {
      while (1) {
        switch (_context11.prev = _context11.next) {
          case 0:
            if (!(!this._isInitialized || this._watchmanClient)) {
              _context11.next = 2;
              break;
            }

            return _context11.abrupt('return', null);

          case 2:
            return _context11.abrupt('return', Promise.all(params.changes.map(function _callee4(change) {
              var uri, text, _contents, diagnostics;

              return regeneratorRuntime.async(function _callee4$(_context10) {
                while (1) {
                  switch (_context10.prev = _context10.next) {
                    case 0:
                      if (!(change.type === _graphqlLanguageServiceTypes.FileChangeTypeKind.Created || change.type === _graphqlLanguageServiceTypes.FileChangeTypeKind.Changed)) {
                        _context10.next = 14;
                        break;
                      }

                      uri = change.uri;
                      text = (0, _fs.readFileSync)(new _url.URL(uri).pathname).toString();
                      _contents = getQueryAndRange(text, uri);


                      _this4._updateFragmentDefinition(uri, _contents);
                      _this4._updateObjectTypeDefinition(uri, _contents);

                      _context10.next = 8;
                      return regeneratorRuntime.awrap(Promise.all(_contents.map(function _callee3(_ref3) {
                        var query = _ref3.query,
                            range = _ref3.range;
                        var results;
                        return regeneratorRuntime.async(function _callee3$(_context9) {
                          while (1) {
                            switch (_context9.prev = _context9.next) {
                              case 0:
                                _context9.next = 2;
                                return regeneratorRuntime.awrap(_this4._languageService.getDiagnostics(query, uri));

                              case 2:
                                results = _context9.sent;

                                if (!(results && results.length > 0)) {
                                  _context9.next = 7;
                                  break;
                                }

                                return _context9.abrupt('return', processDiagnosticsMessage(results, query, range));

                              case 7:
                                return _context9.abrupt('return', []);

                              case 8:
                              case 'end':
                                return _context9.stop();
                            }
                          }
                        }, null, _this4);
                      })));

                    case 8:
                      _context10.t0 = function (left, right) {
                        return left.concat(right);
                      };

                      diagnostics = _context10.sent.reduce(_context10.t0);


                      _this4._logger.log(JSON.stringify({
                        type: 'usage',
                        messageType: 'workspace/didChangeWatchedFiles',
                        projectName: _this4._graphQLCache.getGraphQLConfig().getProjectNameForFile(uri),
                        fileName: uri
                      }));

                      return _context10.abrupt('return', { uri: uri, diagnostics: diagnostics });

                    case 14:
                      if (change.type === _graphqlLanguageServiceTypes.FileChangeTypeKind.Deleted) {
                        _this4._graphQLCache.updateFragmentDefinitionCache(_this4._graphQLCache.getGraphQLConfig().configDir, change.uri, false);
                        _this4._graphQLCache.updateObjectTypeDefinitionCache(_this4._graphQLCache.getGraphQLConfig().configDir, change.uri, false);
                      }

                    case 15:
                    case 'end':
                      return _context10.stop();
                  }
                }
              }, null, _this4);
            })));

          case 3:
          case 'end':
            return _context11.stop();
        }
      }
    }, null, this);
  };

  MessageProcessor.prototype.handleDefinitionRequest = function handleDefinitionRequest(params, token) {
    var textDocument, position, cachedDocument, found, query, range, result, formatted;
    return regeneratorRuntime.async(function handleDefinitionRequest$(_context12) {
      while (1) {
        switch (_context12.prev = _context12.next) {
          case 0:
            if (this._isInitialized) {
              _context12.next = 2;
              break;
            }

            return _context12.abrupt('return', []);

          case 2:
            if (!(!params || !params.textDocument || !params.position)) {
              _context12.next = 4;
              break;
            }

            throw new Error('`textDocument` and `position` arguments are required.');

          case 4:
            textDocument = params.textDocument;
            position = params.position;
            cachedDocument = this._getCachedDocument(textDocument.uri);

            if (cachedDocument) {
              _context12.next = 9;
              break;
            }

            throw new Error(textDocument.uri + ' is not available.');

          case 9:
            found = cachedDocument.contents.find(function (content) {
              var currentRange = content.range;
              if (currentRange && currentRange.containsPosition(position)) {
                return true;
              }
            });

            // If there is no GraphQL query in this file, return an empty result.

            if (found) {
              _context12.next = 12;
              break;
            }

            return _context12.abrupt('return', []);

          case 12:
            query = found.query, range = found.range;

            if (range) {
              position.line -= range.start.line;
            }
            _context12.next = 16;
            return regeneratorRuntime.awrap(this._languageService.getDefinition(query, position, textDocument.uri));

          case 16:
            result = _context12.sent;
            formatted = result ? result.definitions.map(function (res) {
              var defRange = res.range;
              return {
                // TODO: fix this hack!
                // URI is being misused all over this library - there's a link that
                // defines how an URI should be structured:
                // https://tools.ietf.org/html/rfc3986
                // Remove the below hack once the usage of URI is sorted out in related
                // libraries.
                uri: res.path.indexOf('file://') === 0 ? res.path : 'file://' + res.path,
                range: defRange
              };
            }) : [];


            this._logger.log(JSON.stringify({
              type: 'usage',
              messageType: 'textDocument/definition',
              projectName: this._graphQLCache.getGraphQLConfig().getProjectNameForFile(textDocument.uri),
              fileName: textDocument.uri
            }));
            return _context12.abrupt('return', formatted);

          case 20:
          case 'end':
            return _context12.stop();
        }
      }
    }, null, this);
  };

  MessageProcessor.prototype._isRelayCompatMode = function _isRelayCompatMode(query) {
    return query.indexOf('RelayCompat') !== -1 || query.indexOf('react-relay/compat') !== -1;
  };

  MessageProcessor.prototype._updateFragmentDefinition = function _updateFragmentDefinition(uri, contents) {
    var rootDir;
    return regeneratorRuntime.async(function _updateFragmentDefinition$(_context13) {
      while (1) {
        switch (_context13.prev = _context13.next) {
          case 0:
            rootDir = this._graphQLCache.getGraphQLConfig().configDir;
            _context13.next = 3;
            return regeneratorRuntime.awrap(this._graphQLCache.updateFragmentDefinition(rootDir, new _url.URL(uri).pathname, contents));

          case 3:
          case 'end':
            return _context13.stop();
        }
      }
    }, null, this);
  };

  MessageProcessor.prototype._updateObjectTypeDefinition = function _updateObjectTypeDefinition(uri, contents) {
    var rootDir;
    return regeneratorRuntime.async(function _updateObjectTypeDefinition$(_context14) {
      while (1) {
        switch (_context14.prev = _context14.next) {
          case 0:
            rootDir = this._graphQLCache.getGraphQLConfig().configDir;
            _context14.next = 3;
            return regeneratorRuntime.awrap(this._graphQLCache.updateObjectTypeDefinition(rootDir, new _url.URL(uri).pathname, contents));

          case 3:
          case 'end':
            return _context14.stop();
        }
      }
    }, null, this);
  };

  MessageProcessor.prototype._getCachedDocument = function _getCachedDocument(uri) {
    if (this._textDocumentCache.has(uri)) {
      var cachedDocument = this._textDocumentCache.get(uri);
      if (cachedDocument) {
        return cachedDocument;
      }
    }

    return null;
  };

  MessageProcessor.prototype._invalidateCache = function _invalidateCache(textDocument, uri, contents) {
    if (this._textDocumentCache.has(uri)) {
      var cachedDocument = this._textDocumentCache.get(uri);
      if (cachedDocument && cachedDocument.version < textDocument.version) {
        // Current server capabilities specify the full sync of the contents.
        // Therefore always overwrite the entire content.
        this._textDocumentCache.set(uri, {
          version: textDocument.version,
          contents: contents
        });
      }
    } else {
      this._textDocumentCache.set(uri, {
        version: textDocument.version,
        contents: contents
      });
    }
  };

  return MessageProcessor;
}();

/**
 * Helper functions to perform requested services from client/server.
 */

// Check the uri to determine the file type (JavaScript/GraphQL).
// If .js file, either return the parsed query/range or null if GraphQL queries
// are not found.


function getQueryAndRange(text, uri) {
  // Check if the text content includes a GraphQLV query.
  // If the text doesn't include GraphQL queries, do not proceed.
  if ((0, _path.extname)(uri) === '.js') {
    if (text.indexOf('graphql`') === -1 && text.indexOf('graphql.experimental`') === -1) {
      return [];
    }
    var templates = (0, _findGraphQLTags.findGraphQLTags)(text);
    return templates.map(function (_ref4) {
      var template = _ref4.template,
          range = _ref4.range;
      return { query: template, range: range };
    });
  } else {
    var query = text;
    if (!query && query !== '') {
      return [];
    }
    var lines = query.split('\n');
    var range = new _graphqlLanguageServiceUtils.Range(new _graphqlLanguageServiceUtils.Position(0, 0), new _graphqlLanguageServiceUtils.Position(lines.length - 1, lines[lines.length - 1].length - 1));
    return [{ query: query, range: range }];
  }
}

function processDiagnosticsMessage(results, query, range) {
  var queryLines = query.split('\n');
  var totalLines = queryLines.length;
  var lastLineLength = queryLines[totalLines - 1].length;
  var lastCharacterPosition = new _graphqlLanguageServiceUtils.Position(totalLines, lastLineLength);
  var processedResults = results.filter(function (diagnostic) {
    return diagnostic.range.end.lessThanOrEqualTo(lastCharacterPosition);
  });

  if (range) {
    var offset = range.start;
    return processedResults.map(function (diagnostic) {
      return _extends({}, diagnostic, {
        range: new _graphqlLanguageServiceUtils.Range(new _graphqlLanguageServiceUtils.Position(diagnostic.range.start.line + offset.line, diagnostic.range.start.character), new _graphqlLanguageServiceUtils.Position(diagnostic.range.end.line + offset.line, diagnostic.range.end.character))
      });
    });
  }

  return processedResults;
}