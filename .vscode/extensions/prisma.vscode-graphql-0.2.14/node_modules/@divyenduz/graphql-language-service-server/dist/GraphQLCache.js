'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GraphQLCache = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.getGraphQLCache = getGraphQLCache;

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _graphql = require('graphql');

var _nullthrows = require('nullthrows');

var _nullthrows2 = _interopRequireDefault(_nullthrows);

var _kinds = require('graphql/language/kinds');

var _graphqlConfig = require('graphql-config');

var _MessageProcessor = require('./MessageProcessor');

var _stringToHash = require('./stringToHash');

var _stringToHash2 = _interopRequireDefault(_stringToHash);

var _glob = require('glob');

var _glob2 = _interopRequireDefault(_glob);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
                                                                                                                                                           *  Copyright (c) Facebook, Inc.
                                                                                                                                                           *  All rights reserved.
                                                                                                                                                           *
                                                                                                                                                           *  This source code is licensed under the license found in the
                                                                                                                                                           *  LICENSE file in the root directory of this source tree.
                                                                                                                                                           *
                                                                                                                                                           *  
                                                                                                                                                           */

// Maximum files to read when processing GraphQL files.
var MAX_READS = 200;

function getGraphQLCache(configDir, extensions) {
  var graphQLConfig, i, extension;
  return regeneratorRuntime.async(function getGraphQLCache$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return regeneratorRuntime.awrap((0, _graphqlConfig.getGraphQLConfig)(configDir));

        case 2:
          graphQLConfig = _context.sent;

          if (!(extensions && extensions.length > 0)) {
            _context.next = 13;
            break;
          }

          i = 0;

        case 5:
          if (!(i < extensions.length)) {
            _context.next = 13;
            break;
          }

          extension = extensions[i];
          _context.next = 9;
          return regeneratorRuntime.awrap(extension(graphQLConfig));

        case 9:
          graphQLConfig = _context.sent;

        case 10:
          i++;
          _context.next = 5;
          break;

        case 13:
          return _context.abrupt('return', new GraphQLCache(configDir, graphQLConfig));

        case 14:
        case 'end':
          return _context.stop();
      }
    }
  }, null, this);
}

var GraphQLCache = exports.GraphQLCache = function () {
  function GraphQLCache(configDir, graphQLConfig) {
    var _this = this;

    _classCallCheck(this, GraphQLCache);

    this.getGraphQLConfig = function () {
      return _this._graphQLConfig;
    };

    this.getFragmentDependencies = function _callee(query, fragmentDefinitions) {
      var parsedQuery;
      return regeneratorRuntime.async(function _callee$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (fragmentDefinitions) {
                _context2.next = 2;
                break;
              }

              return _context2.abrupt('return', []);

            case 2:
              // If the query cannot be parsed, validations cannot happen yet.
              // Return an empty array.
              parsedQuery = void 0;
              _context2.prev = 3;

              parsedQuery = (0, _graphql.parse)(query);
              _context2.next = 10;
              break;

            case 7:
              _context2.prev = 7;
              _context2.t0 = _context2['catch'](3);
              return _context2.abrupt('return', []);

            case 10:
              return _context2.abrupt('return', _this.getFragmentDependenciesForAST(parsedQuery, fragmentDefinitions));

            case 11:
            case 'end':
              return _context2.stop();
          }
        }
      }, null, _this, [[3, 7]]);
    };

    this.getFragmentDependenciesForAST = function _callee2(parsedQuery, fragmentDefinitions) {
      var existingFrags, referencedFragNames, asts, referencedFragments;
      return regeneratorRuntime.async(function _callee2$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (fragmentDefinitions) {
                _context3.next = 2;
                break;
              }

              return _context3.abrupt('return', []);

            case 2:
              existingFrags = new Map();
              referencedFragNames = new Set();


              (0, _graphql.visit)(parsedQuery, {
                FragmentDefinition: function FragmentDefinition(node) {
                  existingFrags.set(node.name.value, true);
                },
                FragmentSpread: function FragmentSpread(node) {
                  if (!referencedFragNames.has(node.name.value)) {
                    referencedFragNames.add(node.name.value);
                  }
                }
              });

              asts = new Set();

              referencedFragNames.forEach(function (name) {
                if (!existingFrags.has(name) && fragmentDefinitions.has(name)) {
                  asts.add((0, _nullthrows2.default)(fragmentDefinitions.get(name)));
                }
              });

              referencedFragments = [];


              asts.forEach(function (ast) {
                (0, _graphql.visit)(ast.definition, {
                  FragmentSpread: function FragmentSpread(node) {
                    if (!referencedFragNames.has(node.name.value) && fragmentDefinitions.get(node.name.value)) {
                      asts.add((0, _nullthrows2.default)(fragmentDefinitions.get(node.name.value)));
                      referencedFragNames.add(node.name.value);
                    }
                  }
                });
                if (!existingFrags.has(ast.definition.name.value)) {
                  referencedFragments.push(ast);
                }
              });

              return _context3.abrupt('return', referencedFragments);

            case 10:
            case 'end':
              return _context3.stop();
          }
        }
      }, null, _this);
    };

    this.getFragmentDefinitions = function _callee3(projectConfig) {
      var rootDir, filesFromInputDirs, list, _ref, fragmentDefinitions, graphQLFileMap;

      return regeneratorRuntime.async(function _callee3$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              // This function may be called from other classes.
              // If then, check the cache first.
              rootDir = projectConfig.configDir;

              if (!_this._fragmentDefinitionsCache.has(rootDir)) {
                _context4.next = 3;
                break;
              }

              return _context4.abrupt('return', _this._fragmentDefinitionsCache.get(rootDir) || new Map());

            case 3:
              _context4.next = 5;
              return regeneratorRuntime.awrap(_this._readFilesFromInputDirs(rootDir, projectConfig.includes));

            case 5:
              filesFromInputDirs = _context4.sent;
              list = filesFromInputDirs.filter(function (fileInfo) {
                return projectConfig.includesFile(fileInfo.filePath);
              });
              _context4.next = 9;
              return regeneratorRuntime.awrap(_this.readAllGraphQLFiles(list));

            case 9:
              _ref = _context4.sent;
              fragmentDefinitions = _ref.fragmentDefinitions;
              graphQLFileMap = _ref.graphQLFileMap;


              _this._fragmentDefinitionsCache.set(rootDir, fragmentDefinitions);
              _this._graphQLFileListCache.set(rootDir, graphQLFileMap);

              return _context4.abrupt('return', fragmentDefinitions);

            case 15:
            case 'end':
              return _context4.stop();
          }
        }
      }, null, _this);
    };

    this.getObjectTypeDependencies = function _callee4(query, objectTypeDefinitions) {
      var parsedQuery;
      return regeneratorRuntime.async(function _callee4$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              if (objectTypeDefinitions) {
                _context5.next = 2;
                break;
              }

              return _context5.abrupt('return', []);

            case 2:
              // If the query cannot be parsed, validations cannot happen yet.
              // Return an empty array.
              parsedQuery = void 0;
              _context5.prev = 3;

              parsedQuery = (0, _graphql.parse)(query);
              _context5.next = 10;
              break;

            case 7:
              _context5.prev = 7;
              _context5.t0 = _context5['catch'](3);
              return _context5.abrupt('return', []);

            case 10:
              return _context5.abrupt('return', _this.getObjectTypeDependenciesForAST(parsedQuery, objectTypeDefinitions));

            case 11:
            case 'end':
              return _context5.stop();
          }
        }
      }, null, _this, [[3, 7]]);
    };

    this.getObjectTypeDependenciesForAST = function _callee5(parsedQuery, objectTypeDefinitions) {
      var existingObjectTypes, referencedObjectTypes, asts, referencedObjects;
      return regeneratorRuntime.async(function _callee5$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              if (objectTypeDefinitions) {
                _context6.next = 2;
                break;
              }

              return _context6.abrupt('return', []);

            case 2:
              existingObjectTypes = new Map();
              referencedObjectTypes = new Set();


              (0, _graphql.visit)(parsedQuery, {
                ObjectTypeDefinition: function ObjectTypeDefinition(node) {
                  existingObjectTypes.set(node.name.value, true);
                },
                InputObjectTypeDefinition: function InputObjectTypeDefinition(node) {
                  existingObjectTypes.set(node.name.value, true);
                },
                EnumTypeDefinition: function EnumTypeDefinition(node) {
                  existingObjectTypes.set(node.name.value, true);
                },
                NamedType: function NamedType(node) {
                  if (!referencedObjectTypes.has(node.name.value)) {
                    referencedObjectTypes.add(node.name.value);
                  }
                }
              });

              asts = new Set();

              referencedObjectTypes.forEach(function (name) {
                if (!existingObjectTypes.has(name) && objectTypeDefinitions.has(name)) {
                  asts.add((0, _nullthrows2.default)(objectTypeDefinitions.get(name)));
                }
              });

              referencedObjects = [];


              asts.forEach(function (ast) {
                (0, _graphql.visit)(ast.definition, {
                  NamedType: function NamedType(node) {
                    if (!referencedObjectTypes.has(node.name.value) && objectTypeDefinitions.get(node.name.value)) {
                      asts.add((0, _nullthrows2.default)(objectTypeDefinitions.get(node.name.value)));
                      referencedObjectTypes.add(node.name.value);
                    }
                  }
                });
                if (!existingObjectTypes.has(ast.definition.name.value)) {
                  referencedObjects.push(ast);
                }
              });

              return _context6.abrupt('return', referencedObjects);

            case 10:
            case 'end':
              return _context6.stop();
          }
        }
      }, null, _this);
    };

    this.getObjectTypeDefinitions = function _callee6(projectConfig) {
      var rootDir, filesFromInputDirs, list, _ref2, objectTypeDefinitions, graphQLFileMap;

      return regeneratorRuntime.async(function _callee6$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              // This function may be called from other classes.
              // If then, check the cache first.
              rootDir = projectConfig.configDir;

              if (!_this._typeDefinitionsCache.has(rootDir)) {
                _context7.next = 3;
                break;
              }

              return _context7.abrupt('return', _this._typeDefinitionsCache.get(rootDir) || new Map());

            case 3:
              _context7.next = 5;
              return regeneratorRuntime.awrap(_this._readFilesFromInputDirs(rootDir, projectConfig.includes));

            case 5:
              filesFromInputDirs = _context7.sent;
              list = filesFromInputDirs.filter(function (fileInfo) {
                return projectConfig.includesFile(fileInfo.filePath);
              });
              _context7.next = 9;
              return regeneratorRuntime.awrap(_this.readAllGraphQLFiles(list));

            case 9:
              _ref2 = _context7.sent;
              objectTypeDefinitions = _ref2.objectTypeDefinitions;
              graphQLFileMap = _ref2.graphQLFileMap;

              _this._typeDefinitionsCache.set(rootDir, objectTypeDefinitions);
              _this._graphQLFileListCache.set(rootDir, graphQLFileMap);

              return _context7.abrupt('return', objectTypeDefinitions);

            case 15:
            case 'end':
              return _context7.stop();
          }
        }
      }, null, _this);
    };

    this.handleWatchmanSubscribeEvent = function (rootDir, projectConfig) {
      return function (result) {
        if (result.files && result.files.length > 0) {
          var _graphQLFileMap = _this._graphQLFileListCache.get(rootDir);
          if (!_graphQLFileMap) {
            return;
          }
          result.files.forEach(function _callee7(_ref3) {
            var name = _ref3.name,
                exists = _ref3.exists,
                size = _ref3.size,
                mtime = _ref3.mtime;
            var filePath, existingFile, fileAndContent;
            return regeneratorRuntime.async(function _callee7$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    if (projectConfig.includesFile(name)) {
                      _context8.next = 2;
                      break;
                    }

                    return _context8.abrupt('return');

                  case 2:
                    filePath = _path2.default.join(result.root, result.subscription, name);

                    // In the event of watchman recrawl (is_fresh_instance),
                    // watchman subscription returns a full set of files within the
                    // watched directory. After pruning with input/excluded directories,
                    // the file could have been created/modified.
                    // Using the cached size/mtime information, only cache the file if
                    // the file doesn't exist or the file exists and one of or both
                    // size/mtime is different.

                    if (!(result.is_fresh_instance && exists)) {
                      _context8.next = 13;
                      break;
                    }

                    existingFile = _graphQLFileMap.get(filePath);
                    // Same size/mtime means the file stayed the same

                    if (!(existingFile && existingFile.size === size && existingFile.mtime === mtime)) {
                      _context8.next = 7;
                      break;
                    }

                    return _context8.abrupt('return');

                  case 7:
                    _context8.next = 9;
                    return regeneratorRuntime.awrap(_this.promiseToReadGraphQLFile(filePath));

                  case 9:
                    fileAndContent = _context8.sent;

                    _graphQLFileMap.set(filePath, _extends({}, fileAndContent, {
                      size: size,
                      mtime: mtime
                    }));
                    // Otherwise, create/update the cache with the updated file and
                    // content, or delete the cache if (!exists)
                    _context8.next = 22;
                    break;

                  case 13:
                    if (!_graphQLFileMap) {
                      _context8.next = 20;
                      break;
                    }

                    _context8.t0 = _this._graphQLFileListCache;
                    _context8.t1 = rootDir;
                    _context8.next = 18;
                    return regeneratorRuntime.awrap(_this._updateGraphQLFileListCache(_graphQLFileMap, { size: size, mtime: mtime }, filePath, exists));

                  case 18:
                    _context8.t2 = _context8.sent;

                    _context8.t0.set.call(_context8.t0, _context8.t1, _context8.t2);

                  case 20:

                    _this.updateFragmentDefinitionCache(rootDir, filePath, exists);
                    _this.updateObjectTypeDefinitionCache(rootDir, filePath, exists);

                  case 22:
                  case 'end':
                    return _context8.stop();
                }
              }
            }, null, _this);
          });
        }
      };
    };

    this._readFilesFromInputDirs = function (rootDir, includes) {
      var pattern = void 0;

      if (includes.length === 0) {
        return Promise.resolve([]);
      }

      // See https://github.com/graphql/graphql-language-service/issues/221
      // for details on why special handling is required here for the
      // includes.length === 1 case.
      if (includes.length === 1) {
        pattern = includes[0];
      } else {
        pattern = '{' + includes.join(',') + '}';
      }

      return new Promise(function (resolve, reject) {
        var globResult = new _glob2.default.Glob(pattern, {
          cwd: rootDir,
          stat: true,
          absolute: false,
          ignore: ['generated/relay', '**/__flow__/**', '**/__generated__/**', '**/__github__/**', '**/__mocks__/**', '**/node_modules/**', '**/__flowtests__/**']
        }, function (error, results) {
          if (error) {
            reject(error);
          }
        });
        globResult.on('end', function () {
          resolve(Object.keys(globResult.statCache).filter(function (filePath) {
            return typeof globResult.statCache[filePath] === 'object';
          }).map(function (filePath) {
            return {
              filePath: filePath,
              mtime: Math.trunc(globResult.statCache[filePath].mtime.getTime() / 1000),
              size: globResult.statCache[filePath].size
            };
          }));
        });
      });
    };

    this.getSchema = function _callee8(appName) {
      var queryHasExtensions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var projectConfig, projectName, schemaPath, endpointInfo, schemaCacheKey, schema, _endpoint, endpointName, customDirectives, directivesSDL;

      return regeneratorRuntime.async(function _callee8$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              projectConfig = _this._graphQLConfig.getProjectConfig(appName);

              if (projectConfig) {
                _context9.next = 3;
                break;
              }

              return _context9.abrupt('return', null);

            case 3:
              projectName = appName || 'undefinedName';
              schemaPath = projectConfig.schemaPath;
              endpointInfo = _this._getDefaultEndpoint(projectConfig);
              schemaCacheKey = null;
              schema = null;

              if (!endpointInfo) {
                _context9.next = 22;
                break;
              }

              _endpoint = endpointInfo.endpoint, endpointName = endpointInfo.endpointName;


              schemaCacheKey = endpointName + ':' + projectName;

              // Maybe use cache

              if (!_this._schemaMap.has(schemaCacheKey)) {
                _context9.next = 14;
                break;
              }

              schema = _this._schemaMap.get(schemaCacheKey);
              return _context9.abrupt('return', schema && queryHasExtensions ? _this._extendSchema(schema, schemaPath, schemaCacheKey) : schema);

            case 14:
              _context9.prev = 14;
              _context9.next = 17;
              return regeneratorRuntime.awrap(_endpoint.resolveSchema());

            case 17:
              schema = _context9.sent;
              _context9.next = 22;
              break;

            case 20:
              _context9.prev = 20;
              _context9.t0 = _context9['catch'](14);

            case 22:
              if (!(!schema && schemaPath)) {
                _context9.next = 28;
                break;
              }

              schemaCacheKey = schemaPath + ':' + projectName;

              // Maybe use cache

              if (!_this._schemaMap.has(schemaCacheKey)) {
                _context9.next = 27;
                break;
              }

              schema = _this._schemaMap.get(schemaCacheKey);
              return _context9.abrupt('return', schema && queryHasExtensions ? _this._extendSchema(schema, schemaPath, schemaCacheKey) : schema);

            case 27:

              // Read from disk
              schema = projectConfig.getSchema();

            case 28:
              customDirectives = projectConfig.extensions.customDirectives;

              if (customDirectives && schema) {
                directivesSDL = customDirectives.join('\n\n');

                schema = (0, _graphql.extendSchema)(schema, (0, _graphql.parse)(directivesSDL));
              }

              if (schema) {
                _context9.next = 32;
                break;
              }

              return _context9.abrupt('return', null);

            case 32:

              if (_this._graphQLFileListCache.has(_this._configDir)) {
                schema = _this._extendSchema(schema, schemaPath, schemaCacheKey);
              }

              if (schemaCacheKey) {
                _this._schemaMap.set(schemaCacheKey, schema);
              }
              return _context9.abrupt('return', schema);

            case 35:
            case 'end':
              return _context9.stop();
          }
        }
      }, null, _this, [[14, 20]]);
    };

    this.readAllGraphQLFiles = function _callee9(list) {
      var queue, responses, chunk, promises;
      return regeneratorRuntime.async(function _callee9$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              queue = list.slice(); // copy

              responses = [];

            case 2:
              if (!queue.length) {
                _context10.next = 9;
                break;
              }

              chunk = queue.splice(0, MAX_READS);
              promises = chunk.map(function (fileInfo) {
                return _this.promiseToReadGraphQLFile(fileInfo.filePath).catch(function (error) {
                  /**
                   * fs emits `EMFILE | ENFILE` error when there are too many
                   * open files - this can cause some fragment files not to be
                   * processed.  Solve this case by implementing a queue to save
                   * files failed to be processed because of `EMFILE` error,
                   * and await on Promises created with the next batch from the
                   * queue.
                   */
                  if (error.code === 'EMFILE' || error.code === 'ENFILE') {
                    queue.push(fileInfo);
                  }
                }).then(function (response) {
                  return responses.push(_extends({}, response, {
                    mtime: fileInfo.mtime,
                    size: fileInfo.size
                  }));
                });
              });
              _context10.next = 7;
              return regeneratorRuntime.awrap(Promise.all(promises));

            case 7:
              _context10.next = 2;
              break;

            case 9:
              return _context10.abrupt('return', _this.processGraphQLFiles(responses));

            case 10:
            case 'end':
              return _context10.stop();
          }
        }
      }, null, _this);
    };

    this.processGraphQLFiles = function (responses) {
      var objectTypeDefinitions = new Map();
      var fragmentDefinitions = new Map();
      var graphQLFileMap = new Map();

      responses.forEach(function (response) {
        var filePath = response.filePath,
            content = response.content,
            asts = response.asts,
            mtime = response.mtime,
            size = response.size;


        if (asts) {
          asts.forEach(function (ast) {
            ast.definitions.forEach(function (definition) {
              if (definition.kind === _kinds.FRAGMENT_DEFINITION) {
                fragmentDefinitions.set(definition.name.value, {
                  filePath: filePath,
                  content: content,
                  definition: definition
                });
              }
              if (definition.kind === _kinds.OBJECT_TYPE_DEFINITION || definition.kind === _kinds.INPUT_OBJECT_TYPE_DEFINITION || definition.kind === _kinds.ENUM_TYPE_DEFINITION) {
                objectTypeDefinitions.set(definition.name.value, {
                  filePath: filePath,
                  content: content,
                  definition: definition
                });
              }
            });
          });
        }

        // Relay the previous object whether or not ast exists.
        graphQLFileMap.set(filePath, {
          filePath: filePath,
          content: content,
          asts: asts,
          mtime: mtime,
          size: size
        });
      });

      return { objectTypeDefinitions: objectTypeDefinitions, fragmentDefinitions: fragmentDefinitions, graphQLFileMap: graphQLFileMap };
    };

    this.promiseToReadGraphQLFile = function (filePath) {
      return new Promise(function (resolve, reject) {
        return _fs2.default.readFile(filePath, 'utf8', function (error, content) {
          if (error) {
            reject(error);
            return;
          }

          var asts = [];
          var queries = [];
          if (content.trim().length !== 0) {
            try {
              queries = (0, _MessageProcessor.getQueryAndRange)(content, filePath);
              if (queries.length === 0) {
                // still resolve with an empty ast
                resolve({ filePath: filePath, content: content, asts: [], queries: [] });
                return;
              }

              queries.forEach(function (_ref4) {
                var query = _ref4.query;
                return asts.push((0, _graphql.parse)(query));
              });
            } catch (_) {
              // If query has syntax errors, go ahead and still resolve
              // the filePath and the content, but leave ast empty.
              resolve({ filePath: filePath, content: content, asts: [], queries: [] });
              return;
            }
          }
          resolve({ filePath: filePath, content: content, asts: asts, queries: queries });
        });
      });
    };

    this._configDir = configDir;
    this._graphQLConfig = graphQLConfig;
    this._graphQLFileListCache = new Map();
    this._schemaMap = new Map();
    this._fragmentDefinitionsCache = new Map();
    this._typeDefinitionsCache = new Map();
    this._typeExtensionMap = new Map();
  }

  GraphQLCache.prototype._updateGraphQLFileListCache = function _updateGraphQLFileListCache(graphQLFileMap, metrics, filePath, exists) {
    var fileAndContent, graphQLFileInfo, existingFile;
    return regeneratorRuntime.async(function _updateGraphQLFileListCache$(_context11) {
      while (1) {
        switch (_context11.prev = _context11.next) {
          case 0:
            if (!exists) {
              _context11.next = 6;
              break;
            }

            _context11.next = 3;
            return regeneratorRuntime.awrap(this.promiseToReadGraphQLFile(filePath));

          case 3:
            _context11.t0 = _context11.sent;
            _context11.next = 7;
            break;

          case 6:
            _context11.t0 = null;

          case 7:
            fileAndContent = _context11.t0;
            graphQLFileInfo = _extends({}, fileAndContent, metrics);
            existingFile = graphQLFileMap.get(filePath);

            // 3 cases for the cache invalidation: create/modify/delete.
            // For create/modify, swap the existing entry if available;
            // otherwise, just push in the new entry created.
            // For delete, check `exists` and splice the file out.

            if (existingFile && !exists) {
              graphQLFileMap.delete(filePath);
            } else if (graphQLFileInfo) {
              graphQLFileMap.set(filePath, graphQLFileInfo);
            }

            return _context11.abrupt('return', graphQLFileMap);

          case 12:
          case 'end':
            return _context11.stop();
        }
      }
    }, null, this);
  };

  GraphQLCache.prototype.updateFragmentDefinition = function updateFragmentDefinition(rootDir, filePath, contents) {
    var cache, asts;
    return regeneratorRuntime.async(function updateFragmentDefinition$(_context12) {
      while (1) {
        switch (_context12.prev = _context12.next) {
          case 0:
            cache = this._fragmentDefinitionsCache.get(rootDir);
            asts = contents.map(function (_ref5) {
              var query = _ref5.query;

              try {
                return { ast: (0, _graphql.parse)(query), query: query };
              } catch (error) {
                return { ast: null, query: query };
              }
            });

            if (cache) {
              // first go through the fragment list to delete the ones from this file
              cache.forEach(function (value, key) {
                if (value.filePath === filePath) {
                  cache.delete(key);
                }
              });
              asts.forEach(function (_ref6) {
                var ast = _ref6.ast,
                    query = _ref6.query;

                if (!ast) {
                  return;
                }
                ast.definitions.forEach(function (definition) {
                  if (definition.kind === _kinds.FRAGMENT_DEFINITION) {
                    cache.set(definition.name.value, {
                      filePath: filePath,
                      content: query,
                      definition: definition
                    });
                  }
                });
              });
            }

          case 3:
          case 'end':
            return _context12.stop();
        }
      }
    }, null, this);
  };

  GraphQLCache.prototype.updateFragmentDefinitionCache = function updateFragmentDefinitionCache(rootDir, filePath, exists) {
    var fileAndContent, cache;
    return regeneratorRuntime.async(function updateFragmentDefinitionCache$(_context13) {
      while (1) {
        switch (_context13.prev = _context13.next) {
          case 0:
            if (!exists) {
              _context13.next = 6;
              break;
            }

            _context13.next = 3;
            return regeneratorRuntime.awrap(this.promiseToReadGraphQLFile(filePath));

          case 3:
            _context13.t0 = _context13.sent;
            _context13.next = 7;
            break;

          case 6:
            _context13.t0 = null;

          case 7:
            fileAndContent = _context13.t0;

            // In the case of fragment definitions, the cache could just map the
            // definition name to the parsed ast, whether or not it existed
            // previously.
            // For delete, remove the entry from the set.
            if (!exists) {
              cache = this._fragmentDefinitionsCache.get(rootDir);

              if (cache) {
                cache.delete(filePath);
              }
            } else if (fileAndContent && fileAndContent.queries) {
              this.updateFragmentDefinition(rootDir, filePath, fileAndContent.queries);
            }

          case 9:
          case 'end':
            return _context13.stop();
        }
      }
    }, null, this);
  };

  GraphQLCache.prototype.updateObjectTypeDefinition = function updateObjectTypeDefinition(rootDir, filePath, contents) {
    var cache, asts;
    return regeneratorRuntime.async(function updateObjectTypeDefinition$(_context14) {
      while (1) {
        switch (_context14.prev = _context14.next) {
          case 0:
            cache = this._typeDefinitionsCache.get(rootDir);
            asts = contents.map(function (_ref7) {
              var query = _ref7.query;

              try {
                return { ast: (0, _graphql.parse)(query), query: query };
              } catch (error) {
                return { ast: null, query: query };
              }
            });

            if (cache) {
              // first go through the types list to delete the ones from this file
              cache.forEach(function (value, key) {
                if (value.filePath === filePath) {
                  cache.delete(key);
                }
              });
              asts.forEach(function (_ref8) {
                var ast = _ref8.ast,
                    query = _ref8.query;

                if (!ast) {
                  return;
                }
                ast.definitions.forEach(function (definition) {
                  if (definition.kind === _kinds.OBJECT_TYPE_DEFINITION || definition.kind === _kinds.INPUT_OBJECT_TYPE_DEFINITION || definition.kind === _kinds.ENUM_TYPE_DEFINITION) {
                    cache.set(definition.name.value, {
                      filePath: filePath,
                      content: query,
                      definition: definition
                    });
                  }
                });
              });
            }

          case 3:
          case 'end':
            return _context14.stop();
        }
      }
    }, null, this);
  };

  GraphQLCache.prototype.updateObjectTypeDefinitionCache = function updateObjectTypeDefinitionCache(rootDir, filePath, exists) {
    var fileAndContent, cache;
    return regeneratorRuntime.async(function updateObjectTypeDefinitionCache$(_context15) {
      while (1) {
        switch (_context15.prev = _context15.next) {
          case 0:
            if (!exists) {
              _context15.next = 6;
              break;
            }

            _context15.next = 3;
            return regeneratorRuntime.awrap(this.promiseToReadGraphQLFile(filePath));

          case 3:
            _context15.t0 = _context15.sent;
            _context15.next = 7;
            break;

          case 6:
            _context15.t0 = null;

          case 7:
            fileAndContent = _context15.t0;

            // In the case of type definitions, the cache could just map the
            // definition name to the parsed ast, whether or not it existed
            // previously.
            // For delete, remove the entry from the set.
            if (!exists) {
              cache = this._typeDefinitionsCache.get(rootDir);

              if (cache) {
                cache.delete(filePath);
              }
            } else if (fileAndContent && fileAndContent.queries) {
              this.updateObjectTypeDefinition(rootDir, filePath, fileAndContent.queries);
            }

          case 9:
          case 'end':
            return _context15.stop();
        }
      }
    }, null, this);
  };

  GraphQLCache.prototype._extendSchema = function _extendSchema(schema, schemaPath, schemaCacheKey) {
    var graphQLFileMap = this._graphQLFileListCache.get(this._configDir);
    var typeExtensions = [];

    if (!graphQLFileMap) {
      return schema;
    }
    graphQLFileMap.forEach(function (_ref9) {
      var filePath = _ref9.filePath,
          asts = _ref9.asts;

      asts.forEach(function (ast) {
        if (filePath === schemaPath) {
          return;
        }
        ast.definitions.forEach(function (definition) {
          switch (definition.kind) {
            case _kinds.OBJECT_TYPE_DEFINITION:
            case _kinds.INTERFACE_TYPE_DEFINITION:
            case _kinds.ENUM_TYPE_DEFINITION:
            case _kinds.UNION_TYPE_DEFINITION:
            case _kinds.SCALAR_TYPE_DEFINITION:
            case _kinds.INPUT_OBJECT_TYPE_DEFINITION:
            case _kinds.SCALAR_TYPE_EXTENSION:
            case _kinds.OBJECT_TYPE_EXTENSION:
            case _kinds.INTERFACE_TYPE_EXTENSION:
            case _kinds.UNION_TYPE_EXTENSION:
            case _kinds.ENUM_TYPE_EXTENSION:
            case _kinds.INPUT_OBJECT_TYPE_EXTENSION:
            case _kinds.DIRECTIVE_DEFINITION:
              typeExtensions.push(definition);
              break;
          }
        });
      });
    });

    if (schemaCacheKey) {
      var sorted = typeExtensions.sort(function (a, b) {
        var aName = a.definition ? a.definition.name.value : a.name.value;
        var bName = b.definition ? b.definition.name.value : b.name.value;
        return aName > bName ? 1 : -1;
      });
      var hash = (0, _stringToHash2.default)(JSON.stringify(sorted));

      if (this._typeExtensionMap.has(schemaCacheKey) && this._typeExtensionMap.get(schemaCacheKey) === hash) {
        return schema;
      }

      this._typeExtensionMap.set(schemaCacheKey, hash);
    }

    return (0, _graphql.extendSchema)(schema, {
      kind: _kinds.DOCUMENT,
      definitions: typeExtensions
    });
  };

  GraphQLCache.prototype._getDefaultEndpoint = function _getDefaultEndpoint(projectConfig) {
    // Jumping through hoops to get the default endpoint by name (needed for cache key)
    var endpointsExtension = projectConfig.endpointsExtension;
    if (!endpointsExtension) {
      return null;
    }

    var defaultRawEndpoint = endpointsExtension.getRawEndpoint();
    var rawEndpointsMap = endpointsExtension.getRawEndpointsMap();
    var endpointName = Object.keys(rawEndpointsMap).find(function (name) {
      return rawEndpointsMap[name] === defaultRawEndpoint;
    });

    if (!endpointName) {
      return null;
    }

    return {
      endpointName: endpointName,
      endpoint: endpointsExtension.getEndpoint(endpointName)
    };
  };

  /**
   * Given a list of GraphQL file metadata, read all files collected from watchman
   * and create fragmentDefinitions and GraphQL files cache.
   */


  /**
   * Takes an array of GraphQL File information and batch-processes into a
   * map of fragmentDefinitions and GraphQL file cache.
   */


  /**
   * Returns a Promise to read a GraphQL file and return a GraphQL metadata
   * including a parsed AST.
   */


  return GraphQLCache;
}();